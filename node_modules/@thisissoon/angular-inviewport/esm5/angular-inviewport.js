import { ChangeDetectorRef, Directive, ElementRef, EventEmitter, HostBinding, Injectable, Input, NgModule, NgZone, Output } from '@angular/core';
import { Observable as Observable$1 } from 'rxjs/Observable';
import { Subject as Subject$1 } from 'rxjs/Subject';
import { fromEvent as fromEvent$1 } from 'rxjs/observable/fromEvent';
import 'rxjs/add/operator/auditTime';
import 'rxjs/add/operator/debounceTime';
import 'rxjs/add/operator/takeUntil';
import 'rxjs/add/observable/merge';
var __decorate$1 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Service that acts a reference to window object
 * in platforms where `window` does not exists
 *
 * @export
 * @class WindowRef
 */
var WindowRef = (function () {
    function WindowRef() {
    }
    return WindowRef;
}());
WindowRef = __decorate$1([
    Injectable()
], WindowRef);
var eventPathScroll = [
    '$event.target.defaultView.innerHeight',
    '$event.target.defaultView.innerWidth',
    '$event.target.defaultView.scrollY',
    '$event.target.defaultView.scrollX'
];
var eventPathResize = [
    '$event.target.innerHeight',
    '$event.target.innerWidth',
    '$event.target.scrollY',
    '$event.target.scrollX'
];
var eventWindowResize = 'resize';
var eventWindowScroll = 'scroll';
var inViewportClass = 'class.sn-viewport-in';
var notInViewportClass = 'class.sn-viewport-out';
var eventScroll = 'scroll';
var __decorate$2 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
/**
 * A simple lightweight library for Angular (2+) with no
 * external dependencies that detects when an element is within the
 * browser viewport and adds a `in-viewport` or `not-in-viewport` class
 * to the element.
 *
 * @example
 * ```
 * <p
 *  class="foo"
 *  snInViewport
 *  (inViewportChange)="myEventHandler($event)"
 *  [debounce]="300">
 *  Amet tempor excepteur occaecat nulla.
 * </p>
 * ```
 *
 * @export
 * @class InViewportDirective
 */
var InViewportDirective = (function () {
    /**
     * Creates an instance of InViewportDirective.
     * @param {ElementRef} el
     * @param {WindowRef} win
     * @param {ChangeDetectorRef} cdRef
     * @param {NgZone} ngZone
     * @memberof InViewportDirective
     */
    function InViewportDirective(el, win, cdRef, ngZone) {
        this.el = el;
        this.win = win;
        this.cdRef = cdRef;
        this.ngZone = ngZone;
        /**
         * Observable that returns the size of the viewport
         *
         * @private
         * @type {Subject<void>}
         * @memberof InViewportDirective
         */
        this.viewport$ = new Subject$1();
        /**
         * Completes on component destroy lifecycle event
         * use to handle unsubscription from infinite observables
         *
         * @type {Subject<void>}
         * @memberof InViewportDirective
         */
        this.ngUnsubscribe$ = new Subject$1();
        /**
         * Emits event when `inViewport` value changes
         * @type {EventEmitter<boolean>}
         * @memberof InViewportDirective
         */
        this.inViewportChange = new EventEmitter();
        /**
         * Amount of time in ms to wait for other scroll events
         * before running event handler
         *
         * @type {number}
         * @default 100
         * @memberof InViewportDirective
         */
        this.debounce = 100;
    }
    Object.defineProperty(InViewportDirective.prototype, "isInViewport", {
        /**
         * Returns true if element is in viewport
         *
         * @readonly
         * @type {boolean}
         * @memberof InViewportDirective
         */
        get: function () {
            return this.inViewport;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InViewportDirective.prototype, "isNotInViewport", {
        /**
         * Returns true if element is not in viewport
         *
         * @readonly
         * @type {boolean}
         * @memberof InViewportDirective
         */
        get: function () {
            return !this.inViewport;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InViewportDirective.prototype, "viewport", {
        /**
         * Get window viewport values
         *
         * @readonly
         * @type {Viewport}
         * @memberof InViewportDirective
         */
        get: function () {
            var bottom = this.win.innerHeight;
            var left = 0;
            var right = this.win.innerWidth;
            var top = 0;
            return { bottom: bottom, right: right, left: left, top: top };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Subscribe to `viewport$` observable which
     * will call event handler
     *
     * @memberof InViewportDirective
     */
    InViewportDirective.prototype.ngAfterViewInit = function () {
        var _this = this;
        this.calculateInViewportStatus();
        this.cdRef.detectChanges();
        this.viewport$
            .takeUntil(this.ngUnsubscribe$)
            .debounceTime(this.debounce)
            .subscribe(function () { return _this.calculateInViewportStatus(); });
        // Listen for window scroll/resize events.
        this.ngZone.runOutsideAngular(function () {
            Observable$1.merge(fromEvent$1(_this.win, eventWindowResize), fromEvent$1(_this.win, eventWindowScroll))
                .auditTime(_this.debounce)
                .subscribe(function () { return _this.onViewportChange(); });
        });
        if (this.parent) {
            this.ngZone.runOutsideAngular(function () {
                fromEvent$1(_this.parent, eventScroll)
                    .auditTime(_this.debounce)
                    .subscribe(function () { return _this.onParentScroll(); });
            });
        }
    };
    /**
     * Get window element from parent scroll event and
     * emit next value in `viewport$` observable
     *
     * @memberof InViewportDirective
     */
    InViewportDirective.prototype.onParentScroll = function () {
        this.viewport$.next();
    };
    /**
     * On window scroll/resize/load events
     * emit next `viewport$` observable value
     *
     * @memberof InViewportDirective
     */
    InViewportDirective.prototype.onViewportChange = function () {
        this.viewport$.next();
    };
    /**
     * Calculate inViewport status and emit event
     * when viewport status has changed
     *
     * @memberof InViewportDirective
     */
    InViewportDirective.prototype.calculateInViewportStatus = function () {
        var _this = this;
        var el = this.el.nativeElement;
        var inParentViewport = false;
        var inWindowViewport = false;
        if (this.parent) {
            var parentBounds = this.parent.getBoundingClientRect();
            inParentViewport = this.isInElementViewport(parentBounds, el);
            inWindowViewport = this.isInElementViewport(this.viewport, this.parent);
        }
        else {
            inParentViewport = true;
            inWindowViewport = this.isInElementViewport(this.viewport, el);
        }
        var oldInViewport = this.inViewport;
        this.inViewport = (inParentViewport && inWindowViewport);
        if (oldInViewport !== this.inViewport) {
            this.ngZone.run(function () { return _this.inViewportChange.emit(_this.inViewport); });
        }
    };
    /**
     * Returns true if an element is currently within the `viewport`
     *
     * @param {Viewport} viewport
     * @param {*} el
     * @returns {boolean}
     * @memberof InViewportDirective
     */
    InViewportDirective.prototype.isInElementViewport = function (viewport, el) {
        // Check if `getBoundingClientRect` is a function in case running this code
        // in an evironment without the DOM
        if (typeof el.getBoundingClientRect === 'function') {
            var elBounds = el.getBoundingClientRect();
            return (((elBounds.top >= viewport.top) && (elBounds.top <= viewport.bottom) ||
                (elBounds.bottom >= viewport.top) && (elBounds.bottom <= viewport.bottom) ||
                (elBounds.top <= viewport.top) && (elBounds.bottom >= viewport.bottom)) &&
                ((elBounds.left >= viewport.left) && (elBounds.left <= viewport.right) ||
                    (elBounds.right >= viewport.left) && (elBounds.right <= viewport.right) ||
                    (elBounds.left <= viewport.left && elBounds.right >= viewport.right)));
        }
        else {
            return false;
        }
    };
    /**
     * trigger `ngUnsubscribe` complete on
     * component destroy lifecycle hook
     *
     * @memberof InViewportDirective
     */
    InViewportDirective.prototype.ngOnDestroy = function () {
        this.ngUnsubscribe$.next();
        this.ngUnsubscribe$.complete();
    };
    return InViewportDirective;
}());
__decorate$2([
    Output(),
    __metadata("design:type", Object)
], InViewportDirective.prototype, "inViewportChange", void 0);
__decorate$2([
    Input(),
    __metadata("design:type", Object)
], InViewportDirective.prototype, "debounce", void 0);
__decorate$2([
    Input(),
    __metadata("design:type", Object)
], InViewportDirective.prototype, "parent", void 0);
__decorate$2([
    HostBinding(inViewportClass),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], InViewportDirective.prototype, "isInViewport", null);
__decorate$2([
    HostBinding(notInViewportClass),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], InViewportDirective.prototype, "isNotInViewport", null);
InViewportDirective = __decorate$2([
    Directive({
        selector: '[inViewport], [snInViewport]'
    }),
    __metadata("design:paramtypes", [ElementRef,
        WindowRef,
        ChangeDetectorRef,
        NgZone])
], InViewportDirective);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var defaultProviders = [
    WindowRef
];
/**
 * A simple lightweight library for Angular 2/4+ with other dependencies
 * that detects when an element is within the browser viewport and adds a
 * sn-viewport-in or sn-viewport-out class to the element.
 *
 * @export
 * @class InViewportModule
 */
var InViewportModule = InViewportModule_1 = (function () {
    function InViewportModule() {
    }
    /**
     * Specify a static method for root module to ensure providers are only provided once
     * but allows the module to still be imported into other modules without reproviding
     * services.
     *
     * @static
     * @returns {ModuleWithProviders}
     * @memberof InViewportModule
     */
    InViewportModule.forRoot = function (providers) {
        if (providers === void 0) { providers = defaultProviders; }
        return {
            ngModule: InViewportModule_1,
            providers: providers
        };
    };
    return InViewportModule;
}());
InViewportModule = InViewportModule_1 = __decorate([
    NgModule({
        declarations: [InViewportDirective],
        exports: [InViewportDirective]
    })
], InViewportModule);
var InViewportModule_1;
/**
 * Generated bundle index. Do not edit.
 */
export { InViewportModule, InViewportDirective, eventPathResize, eventPathScroll, eventScroll, eventWindowResize, eventWindowScroll, inViewportClass, notInViewportClass, WindowRef };
//# sourceMappingURL=angular-inviewport.js.map
