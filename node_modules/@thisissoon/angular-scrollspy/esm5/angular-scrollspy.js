import { ChangeDetectorRef, Component, ContentChildren, Directive, HostBinding, Injectable, Input, NgModule, QueryList } from '@angular/core';
import { InViewportModule } from '@thisissoon/angular-inviewport';
var __decorate$1 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$1 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
/**
 * A directive used to add an `active` class to a nav item
 * when the section is in the viewport
 *
 * @example
 * ```
 * <a snScrollSpyItem for="foo" href="#section1">Section 1</a>
 * ```
 *
 * @export
 * @class ScrollSpyItemDirective
 * @implements {AfterViewInit}
 * @implements {OnDestroy}
 */
var ScrollSpyItemDirective = (function () {
    /**
     * Creates an instance of ScrollSpyItemDirective.
     * @param {ChangeDetectorRef} cdRef
     * @memberof ScrollSpyItemDirective
     */
    function ScrollSpyItemDirective(cdRef) {
        this.cdRef = cdRef;
        /**
         * True if the nav item is the active item in the `items` list
         * for `ScrollSpyDirective` instance
         *
         * @type {boolean}
         * @memberof ScrollSpyItemDirective
         */
        this.active = false;
        /**
         * If true means the section is in the viewport
         *
         * @type {boolean}
         * @memberof ScrollSpyItemDirective
         */
        this.inViewport = false;
    }
    Object.defineProperty(ScrollSpyItemDirective.prototype, "section", {
        /**
         * Id of section that links navigates to
         *
         * @readonly
         * @type {string}
         * @memberof ScrollSpyItemDirective
         */
        get: function () {
            return this.href.replace('#', '');
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Manually trigger change detection
     *
     * @memberof ScrollSpyItemDirective
     */
    ScrollSpyItemDirective.prototype.detectChanges = function () {
        this.cdRef.detectChanges();
    };
    return ScrollSpyItemDirective;
}());
__decorate$1([
    HostBinding('class.active'),
    __metadata$1("design:type", Object)
], ScrollSpyItemDirective.prototype, "active", void 0);
__decorate$1([
    Input(),
    __metadata$1("design:type", String)
], ScrollSpyItemDirective.prototype, "for", void 0);
__decorate$1([
    Input(),
    __metadata$1("design:type", String)
], ScrollSpyItemDirective.prototype, "href", void 0);
ScrollSpyItemDirective = __decorate$1([
    Directive({
        selector: '[snScrollSpyItem]'
    }),
    __metadata$1("design:paramtypes", [ChangeDetectorRef])
], ScrollSpyItemDirective);
var __decorate$2 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Service that stores a list of `Spy`'s and the state
 * of their nav items `inViewport` and `active` state
 *
 * @export
 * @class ScrollSpyService
 */
var ScrollSpyService = (function () {
    /**
     * Service that stores a list of `Spy`'s and the state
     * of their nav items `inViewport` and `active` state
     *
     * @export
     * @class ScrollSpyService
     */
    function ScrollSpyService() {
        /**
         * List of `Spy`'s
         *
         * @type {Spy[]}
         * @memberof ScrollSpyService
         */
        this.spys = [];
        /**
         * Stores requests to add items to spy when spy hasn't been created
         * yet. Once spy has been added then request will be made again.
         *
         * @type {any[]}
         * @memberof ScrollSpyService
         */
        this.buffer = [];
    }
    /**
     * Add spy to list of `spys`
     *
     * @param {string} id
     * @param {QueryList<ScrollSpyItemDirective>} items
     * @memberof ScrollSpyService
     */
    ScrollSpyService.prototype.addSpy = function (id, items) {
        var _this = this;
        this.spys.push({ id: id, items: items });
        var buffer = this.buffer.filter(function (i) { return i.spyId === id; });
        this.buffer = this.buffer.filter(function (i) { return i.spyId !== id; });
        buffer.forEach(function (i) { return _this.setSpySectionStatus(i.sectionId, i.spyId, i.inViewport); });
    };
    /**
     * Remove spy from list of `spys`
     *
     * @param {string} id
     * @memberof ScrollSpyService
     */
    ScrollSpyService.prototype.removeSpy = function (id) {
        var i = this.spys.findIndex(function (s) { return s.id === id; });
        this.spys.splice(i, 1);
    };
    /**
     * Set the `inViewport` status for a spy item then sets the active
     * to true for the first item in the list that has `inViewport`
     * set to true
     *
     * @param {string} sectionId
     * @param {string} spyId
     * @param {boolean} inViewport
     * @returns {void}
     * @memberof ScrollSpyService
     */
    ScrollSpyService.prototype.setSpySectionStatus = function (sectionId, spyId, inViewport) {
        var spy = this.spys.find(function (s) { return s.id === spyId; });
        if (!spy) {
            this.buffer.push({ sectionId: sectionId, spyId: spyId, inViewport: inViewport });
            return;
        }
        var item = spy.items.find(function (i) { return i.section === sectionId; });
        if (!item) {
            return;
        }
        item.inViewport = inViewport;
        var firstInViewport = spy.items.filter(function (i) { return i.inViewport; })[0];
        spy.items.forEach(function (i) { return i.active = false; });
        if (firstInViewport) {
            firstInViewport.active = true;
            firstInViewport.detectChanges();
        }
    };
    return ScrollSpyService;
}());
ScrollSpyService = __decorate$2([
    Injectable()
], ScrollSpyService);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
/**
 * Adds `active` class to navigation links when section is in the viewport.
 * Used in conjuction with `snScrollItem` directive which should be added
 * to anchor links in the nav
 *
 * @example
 * ```
 * <ul role="navigation" snScrollSpy id="foo">
 *  <li><a snScrollSpyItem for="foo" href="#section1">Section 1</a></li>
 *  <li><a snScrollSpyItem for="foo" href="#section2">Section 2</a></li>
 *  <li><a snScrollSpyItem for="foo" href="#section3">Section 3</a></li>
 *  <li><a snScrollSpyItem for="foo" href="#section4">Section 4</a></li>
 * </ul>
 * ```
 *
 * @export
 * @class ScrollSpyDirective
 * @implements {AfterViewInit}
 * @implements {OnDestroy}
 */
var ScrollSpyDirective = (function () {
    /**
     * Creates an instance of ScrollSpyDirective.
     * @param {ScrollSpyService} scrollSpySvc
     * @memberof ScrollSpyDirective
     */
    function ScrollSpyDirective(scrollSpySvc) {
        this.scrollSpySvc = scrollSpySvc;
    }
    /**
     * Adds spy to list of spys in `ScrollSpyService`
     *
     * @memberof ScrollSpyDirective
     */
    ScrollSpyDirective.prototype.ngAfterViewInit = function () {
        this.scrollSpySvc.addSpy(this.id, this.items);
    };
    /**
     * Remove spy from list of spys when directive is destroyed
     *
     * @memberof ScrollSpyDirective
     */
    ScrollSpyDirective.prototype.ngOnDestroy = function () {
        this.scrollSpySvc.removeSpy(this.id);
    };
    return ScrollSpyDirective;
}());
__decorate([
    ContentChildren(ScrollSpyItemDirective),
    __metadata("design:type", QueryList)
], ScrollSpyDirective.prototype, "items", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ScrollSpyDirective.prototype, "id", void 0);
ScrollSpyDirective = __decorate([
    Directive({
        selector: '[snScrollSpy]',
        queries: {
            spyItems: new ContentChildren(ScrollSpyItemDirective)
        }
    }),
    __metadata("design:paramtypes", [ScrollSpyService])
], ScrollSpyDirective);
var __decorate$3 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$2 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
/**
 * A component to wrap section content within that will update the
 * `ScrollSpyService` when it's in view
 *
 * @example
 * ```
 *  <sn-scroll-spy-section id="section1" for="foo">
 *    ...
 *  </sn-scroll-spy-section>
 * ```
 *
 * @export
 * @class ScrollSpySectionComponent
 */
var ScrollSpySectionComponent = (function () {
    /**
     * Creates an instance of ScrollSpySectionComponent.
     * @param {ScrollSpyService} scrollSpySvc
     * @memberof ScrollSpySectionComponent
     */
    function ScrollSpySectionComponent(scrollSpySvc) {
        this.scrollSpySvc = scrollSpySvc;
        /**
         * Amount of time in ms to wait for other scroll events
         * before running event handler
         *
         * @type {number}
         * @default 0
         * @memberof ScrollSpySectionComponent
         */
        this.debounce = 0;
    }
    /**
     * Updates `ScrollSpy` section when element enters/leaves viewport
     *
     * @param {boolean} inViewport
     * @memberof ScrollSpySectionComponent
     */
    ScrollSpySectionComponent.prototype.onInViewportChange = function (inViewport) {
        this.scrollSpySvc.setSpySectionStatus(this.id, this.for, inViewport);
    };
    return ScrollSpySectionComponent;
}());
__decorate$3([
    Input(),
    __metadata$2("design:type", String)
], ScrollSpySectionComponent.prototype, "id", void 0);
__decorate$3([
    Input(),
    __metadata$2("design:type", String)
], ScrollSpySectionComponent.prototype, "for", void 0);
__decorate$3([
    Input(),
    __metadata$2("design:type", Object)
], ScrollSpySectionComponent.prototype, "debounce", void 0);
ScrollSpySectionComponent = __decorate$3([
    Component({
        selector: 'sn-scroll-spy-section',
        template: "\n    <div\n      class=\"sn-hidden\"\n      snInViewport\n      (inViewportChange)=\"onInViewportChange($event)\"\n      [debounce]=\"debounce\">\n    </div>\n    <ng-content></ng-content>\n  ",
        styles: ["\n    :host {\n      display: block;\n      position: relative; }\n\n    .sn-hidden {\n      bottom: 0;\n      left: 0;\n      opacity: 0;\n      position: absolute;\n      right: 0;\n      top: 0;\n      z-index: -1; }\n  "]
    }),
    __metadata$2("design:paramtypes", [ScrollSpyService])
], ScrollSpySectionComponent);
var __decorate$4 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var directives = [
    ScrollSpyDirective,
    ScrollSpyItemDirective,
];
var components = [
    ScrollSpySectionComponent
];
var providers = [
    ScrollSpyService
];
/**
 * A simple lightweight library for Angular 2/4+ which automatically
 * updates links to indicate the currently active section in the viewport
 *
 * @export
 * @class ScrollSpyModule
 */
var ScrollSpyModule = ScrollSpyModule_1 = (function () {
    function ScrollSpyModule() {
    }
    /**
     * Specify a static method for root module to ensure providers are
     * only provided once but allows the module to still be imported
     * into other modules without reproviding services.
     *
     * @static
     * @returns {ModuleWithProviders}
     * @memberof ScrollSpyModule
     */
    ScrollSpyModule.forRoot = function () {
        return {
            ngModule: ScrollSpyModule_1,
            providers: providers.slice()
        };
    };
    return ScrollSpyModule;
}());
ScrollSpyModule = ScrollSpyModule_1 = __decorate$4([
    NgModule({
        imports: [
            InViewportModule
        ],
        declarations: directives.concat(components),
        exports: directives.concat(components)
    })
], ScrollSpyModule);
var ScrollSpyModule_1;
/**
 * Generated bundle index. Do not edit.
 */
export { ScrollSpyDirective, ScrollSpyItemDirective, ScrollSpySectionComponent, ScrollSpyService, ScrollSpyModule };
//# sourceMappingURL=angular-scrollspy.js.map
