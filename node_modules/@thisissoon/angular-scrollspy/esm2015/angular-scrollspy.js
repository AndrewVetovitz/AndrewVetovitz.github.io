import { ChangeDetectorRef, Component, ContentChildren, Directive, HostBinding, Injectable, Input, NgModule, QueryList } from '@angular/core';
import { InViewportModule } from '@thisissoon/angular-inviewport';

var __decorate$1 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$1 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * A directive used to add an `active` class to a nav item
 * when the section is in the viewport
 *
 * @example
 * ```
 * <a snScrollSpyItem for="foo" href="#section1">Section 1</a>
 * ```
 *
 * @export
 * @class ScrollSpyItemDirective
 * @implements {AfterViewInit}
 * @implements {OnDestroy}
 */
let ScrollSpyItemDirective = class ScrollSpyItemDirective {
    /**
     * Creates an instance of ScrollSpyItemDirective.
     * @param {ChangeDetectorRef} cdRef
     * @memberof ScrollSpyItemDirective
     */
    constructor(cdRef) {
        this.cdRef = cdRef;
        /**
         * True if the nav item is the active item in the `items` list
         * for `ScrollSpyDirective` instance
         *
         * @type {boolean}
         * @memberof ScrollSpyItemDirective
         */
        this.active = false;
        /**
         * If true means the section is in the viewport
         *
         * @type {boolean}
         * @memberof ScrollSpyItemDirective
         */
        this.inViewport = false;
    }
    /**
     * Id of section that links navigates to
     *
     * @readonly
     * @type {string}
     * @memberof ScrollSpyItemDirective
     */
    get section() {
        return this.href.replace('#', '');
    }
    /**
     * Manually trigger change detection
     *
     * @memberof ScrollSpyItemDirective
     */
    detectChanges() {
        this.cdRef.detectChanges();
    }
};
__decorate$1([
    HostBinding('class.active'),
    __metadata$1("design:type", Object)
], ScrollSpyItemDirective.prototype, "active", void 0);
__decorate$1([
    Input(),
    __metadata$1("design:type", String)
], ScrollSpyItemDirective.prototype, "for", void 0);
__decorate$1([
    Input(),
    __metadata$1("design:type", String)
], ScrollSpyItemDirective.prototype, "href", void 0);
ScrollSpyItemDirective = __decorate$1([
    Directive({
        selector: '[snScrollSpyItem]'
    }),
    __metadata$1("design:paramtypes", [ChangeDetectorRef])
], ScrollSpyItemDirective);

var __decorate$2 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Service that stores a list of `Spy`'s and the state
 * of their nav items `inViewport` and `active` state
 *
 * @export
 * @class ScrollSpyService
 */
let ScrollSpyService = class ScrollSpyService {
    /**
     * Service that stores a list of `Spy`'s and the state
     * of their nav items `inViewport` and `active` state
     *
     * @export
     * @class ScrollSpyService
     */
    constructor() {
        /**
         * List of `Spy`'s
         *
         * @type {Spy[]}
         * @memberof ScrollSpyService
         */
        this.spys = [];
        /**
         * Stores requests to add items to spy when spy hasn't been created
         * yet. Once spy has been added then request will be made again.
         *
         * @type {any[]}
         * @memberof ScrollSpyService
         */
        this.buffer = [];
    }
    /**
     * Add spy to list of `spys`
     *
     * @param {string} id
     * @param {QueryList<ScrollSpyItemDirective>} items
     * @memberof ScrollSpyService
     */
    addSpy(id, items) {
        this.spys.push({ id, items });
        const buffer = this.buffer.filter((i) => i.spyId === id);
        this.buffer = this.buffer.filter((i) => i.spyId !== id);
        buffer.forEach((i) => this.setSpySectionStatus(i.sectionId, i.spyId, i.inViewport));
    }
    /**
     * Remove spy from list of `spys`
     *
     * @param {string} id
     * @memberof ScrollSpyService
     */
    removeSpy(id) {
        const i = this.spys.findIndex((s) => s.id === id);
        this.spys.splice(i, 1);
    }
    /**
     * Set the `inViewport` status for a spy item then sets the active
     * to true for the first item in the list that has `inViewport`
     * set to true
     *
     * @param {string} sectionId
     * @param {string} spyId
     * @param {boolean} inViewport
     * @returns {void}
     * @memberof ScrollSpyService
     */
    setSpySectionStatus(sectionId, spyId, inViewport) {
        const spy = this.spys.find((s) => s.id === spyId);
        if (!spy) {
            this.buffer.push({ sectionId, spyId, inViewport });
            return;
        }
        const item = spy.items.find((i) => i.section === sectionId);
        if (!item) {
            return;
        }
        item.inViewport = inViewport;
        const firstInViewport = spy.items.filter((i) => i.inViewport)[0];
        spy.items.forEach((i) => i.active = false);
        if (firstInViewport) {
            firstInViewport.active = true;
            firstInViewport.detectChanges();
        }
    }
};
ScrollSpyService = __decorate$2([
    Injectable()
], ScrollSpyService);

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Adds `active` class to navigation links when section is in the viewport.
 * Used in conjuction with `snScrollItem` directive which should be added
 * to anchor links in the nav
 *
 * @example
 * ```
 * <ul role="navigation" snScrollSpy id="foo">
 *  <li><a snScrollSpyItem for="foo" href="#section1">Section 1</a></li>
 *  <li><a snScrollSpyItem for="foo" href="#section2">Section 2</a></li>
 *  <li><a snScrollSpyItem for="foo" href="#section3">Section 3</a></li>
 *  <li><a snScrollSpyItem for="foo" href="#section4">Section 4</a></li>
 * </ul>
 * ```
 *
 * @export
 * @class ScrollSpyDirective
 * @implements {AfterViewInit}
 * @implements {OnDestroy}
 */
let ScrollSpyDirective = class ScrollSpyDirective {
    /**
     * Creates an instance of ScrollSpyDirective.
     * @param {ScrollSpyService} scrollSpySvc
     * @memberof ScrollSpyDirective
     */
    constructor(scrollSpySvc) {
        this.scrollSpySvc = scrollSpySvc;
    }
    /**
     * Adds spy to list of spys in `ScrollSpyService`
     *
     * @memberof ScrollSpyDirective
     */
    ngAfterViewInit() {
        this.scrollSpySvc.addSpy(this.id, this.items);
    }
    /**
     * Remove spy from list of spys when directive is destroyed
     *
     * @memberof ScrollSpyDirective
     */
    ngOnDestroy() {
        this.scrollSpySvc.removeSpy(this.id);
    }
};
__decorate([
    ContentChildren(ScrollSpyItemDirective),
    __metadata("design:type", QueryList)
], ScrollSpyDirective.prototype, "items", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ScrollSpyDirective.prototype, "id", void 0);
ScrollSpyDirective = __decorate([
    Directive({
        selector: '[snScrollSpy]',
        queries: {
            spyItems: new ContentChildren(ScrollSpyItemDirective)
        }
    }),
    __metadata("design:paramtypes", [ScrollSpyService])
], ScrollSpyDirective);

var __decorate$3 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$2 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * A component to wrap section content within that will update the
 * `ScrollSpyService` when it's in view
 *
 * @example
 * ```
 *  <sn-scroll-spy-section id="section1" for="foo">
 *    ...
 *  </sn-scroll-spy-section>
 * ```
 *
 * @export
 * @class ScrollSpySectionComponent
 */
let ScrollSpySectionComponent = class ScrollSpySectionComponent {
    /**
     * Creates an instance of ScrollSpySectionComponent.
     * @param {ScrollSpyService} scrollSpySvc
     * @memberof ScrollSpySectionComponent
     */
    constructor(scrollSpySvc) {
        this.scrollSpySvc = scrollSpySvc;
        /**
         * Amount of time in ms to wait for other scroll events
         * before running event handler
         *
         * @type {number}
         * @default 0
         * @memberof ScrollSpySectionComponent
         */
        this.debounce = 0;
    }
    /**
     * Updates `ScrollSpy` section when element enters/leaves viewport
     *
     * @param {boolean} inViewport
     * @memberof ScrollSpySectionComponent
     */
    onInViewportChange(inViewport) {
        this.scrollSpySvc.setSpySectionStatus(this.id, this.for, inViewport);
    }
};
__decorate$3([
    Input(),
    __metadata$2("design:type", String)
], ScrollSpySectionComponent.prototype, "id", void 0);
__decorate$3([
    Input(),
    __metadata$2("design:type", String)
], ScrollSpySectionComponent.prototype, "for", void 0);
__decorate$3([
    Input(),
    __metadata$2("design:type", Object)
], ScrollSpySectionComponent.prototype, "debounce", void 0);
ScrollSpySectionComponent = __decorate$3([
    Component({
        selector: 'sn-scroll-spy-section',
        template: `
    <div
      class="sn-hidden"
      snInViewport
      (inViewportChange)="onInViewportChange($event)"
      [debounce]="debounce">
    </div>
    <ng-content></ng-content>
  `,
        styles: [`
    :host {
      display: block;
      position: relative; }

    .sn-hidden {
      bottom: 0;
      left: 0;
      opacity: 0;
      position: absolute;
      right: 0;
      top: 0;
      z-index: -1; }
  `]
    }),
    __metadata$2("design:paramtypes", [ScrollSpyService])
], ScrollSpySectionComponent);

var __decorate$4 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const directives = [
    ScrollSpyDirective,
    ScrollSpyItemDirective,
];
const components = [
    ScrollSpySectionComponent
];
const providers = [
    ScrollSpyService
];
/**
 * A simple lightweight library for Angular 2/4+ which automatically
 * updates links to indicate the currently active section in the viewport
 *
 * @export
 * @class ScrollSpyModule
 */
let ScrollSpyModule = ScrollSpyModule_1 = class ScrollSpyModule {
    /**
     * Specify a static method for root module to ensure providers are
     * only provided once but allows the module to still be imported
     * into other modules without reproviding services.
     *
     * @static
     * @returns {ModuleWithProviders}
     * @memberof ScrollSpyModule
     */
    static forRoot() {
        return {
            ngModule: ScrollSpyModule_1,
            providers: [
                ...providers
            ]
        };
    }
};
ScrollSpyModule = ScrollSpyModule_1 = __decorate$4([
    NgModule({
        imports: [
            InViewportModule
        ],
        declarations: [
            ...directives,
            ...components
        ],
        exports: [
            ...directives,
            ...components
        ]
    })
], ScrollSpyModule);
var ScrollSpyModule_1;

/**
 * Generated bundle index. Do not edit.
 */

export { ScrollSpyDirective, ScrollSpyItemDirective, ScrollSpySectionComponent, ScrollSpyService, ScrollSpyModule };
//# sourceMappingURL=angular-scrollspy.js.map
